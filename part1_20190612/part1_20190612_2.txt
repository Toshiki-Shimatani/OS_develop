// -----------------------------------------------------------------
//  Author  : Shimatani Toshiki <shimatani@swlab.cs.okayama-u.ac.jp>
//  Make_Date   : 2019/06/12 21:00:44
//  Update_Date : 2019/06/28 21:52:42
//  Filename: part1_20190612_2.txt
// -----------------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
このファイルは part1_20190612_2.txt の続きである．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

===========================================================================================================================
次に,レジスタの話をする．岡山大学でシステムプログラミングの単位を取った方はご存じだろう．
情報工学実験Ａの単位を取った方はよりわかるだろう．

part1_20190612_1.txt にて16ビットモードという話が出てきた．
16ビットという値はCPUのレジスタのサイズである．以下ではレジスタについて説明していく．

レジスタとは，CPUの内部にある演算や実行などを管理するメモリ領域である．
この領域を利用することで演算等を高速に行うことができる．

ここからは，過去のIntel製CPUに沿ってレジスタの説明をしていく．
-----------------------------------------------
***
* 8080
***
 1973年に発売された8ビットCPU．アクセスできるメモリ空間は64 KBであった．
 8ビットCPUでありながら，アクセス可能なメモリ空間が64 KBである理由は，
 CPUが16ビットのアドレス指定に対応していたからである．

 レジスタの種類には以下のものがあった．
 =================================
  A , B , C , D , E , H , L , PC , SP , Flag 
 =================================
 これらのうち，PC,SP が16ビットのレジスタであり，他が8ビットレジスタである．
 8080では8ビットレジスタを併せて16ビットとして扱う命令が存在する．詳しくは調べてほしい．

***
* 8086
***
 1978年に発売された16ビットCPU．アクセスできる空間は1 MBであった．
 16ビットCPUでありながら，アクセス可能なメモリ空間が1 MBである理由は，
 CPUが20ビットのアドレス指定に対応していたからである．
 しかし，アクセス可能なメモリ空間を1 MBにしたにもかかわらず，
 プログラム，データ，スタックが64 KB単位でしかアクセスできなかった．
 この64 KBの領域のことをセグメントと呼ぶ．また，このセグメントを取り扱うために
 8086からセグメントレジスタが登場した．8086のレジスタは以下の通りである．

 ===============================================================
  汎用レジスタ　　　 | AX , BX , CX , DX , SI , DI , BP , SP , IP
 ===============================================================
  セグメントレジスタ | CS , DS , SS , ES
 ===============================================================

 また，これらのレジスタのうち，AX，BX，CX，DXは互換性のためにすべて2つの8ビットレジスタとして
 扱うことができる．たとえば AX の場合，AX の上位8ビットを AH ,下位8ビットを AL というように扱える．

 ***
 * 80386
 ***
 1985年に発売された32ビットCPUである．アクセスできるメモリ空間は4 MBとなった． (2^32 = 4,294,967,296)
 これ以降に発売された80486やPentiumは，この80386をベースに進化していったため，このCPUで用いられた命令セットアーキテクチャが
 intelの32ビットCPUの基本となるアーキテクチャとなった．のちにこのアーキテクチャはIA-32と呼ばれる．
 (FreeBSDなどでみられるi386とはintelの32ビットCPUに対応しているファイル群を意味している)
 
 80386の汎用レジスタ以下の通りである．
 ======================================================
  ---------------------------------------------
  #################### EAX ####################
  ---------------------------------------------
                            ######   AX  ######
                            -------------------
                            ## AH  ##||## AL ##
                            -------------------

  ---------------------------------------------
  #################### EBX ####################
  ---------------------------------------------
                            ######   BX  ######
                            -------------------
                            ## BH  ##||## BL ##
                            -------------------
  ---------------------------------------------
  #################### ECX ####################
  ---------------------------------------------
                            ######   CX  ######
                            -------------------
                            ## CH  ##||## CL ##
                            -------------------
  ---------------------------------------------
  #################### EDX ####################
  ---------------------------------------------
                            ######   DX  ######
                            -------------------
                            ## DH  ##||## DL ##
                            -------------------
  ---------------------------------------------
  #################### ESI ####################
  ---------------------------------------------
                            ######   SI  ######

  ---------------------------------------------
  #################### EDI ####################
  ---------------------------------------------
                            ######   DI  ######

  ---------------------------------------------
  #################### EBP ####################
  ---------------------------------------------
                            ######   BP  ######

 ---------------------------------------------
  #################### ESP ####################
  ---------------------------------------------
                            ######   SP  ######

  ---------------------------------------------
  #################### EIP ####################
  ---------------------------------------------
                            ######   IP  ######

  ---------------------------------------------
  ################## FLAGS ####################
  ---------------------------------------------
                            ##### FLAGS  ######                           

 ======================================================
 互換性を持つために，32ビットレジスタを16ビットとして扱うことができ，
 さらに，そこから8ビットレジスタとして扱うことができるレジスタも存在する．

 セグメントレジスタは，以下の通りである．
 ==========================
  CS，DS，ES，SS，FS，GS
 ==========================
 8086からFSとGSの２つが追加されているが，セグメントレジスタ自体は16ビットから変更はない．

　近年では，64ビットCPUが登場しレジスタも64ビットで扱われているが，ここでは説明を割愛させていただく．
-----------------------------------------------　　

以上でレジスタの説明を終える．ここからは16ビットCPUで扱われるレジスタの役割に注視して説明する．

先ほど説明したものに加えて，16ビットCPUでは以下のレジスタが使用される．
各レジスタの使用用途を各レジスタの隣に示す．

+==============+
| 汎用レジスタ | (プログラマが自由に利用できるレジスタ．基本的にどんな使い方をしても構わない．
| 　　　　　　 |  一応，使用方法は存在する．AX,BX,CX,DXは8ビットCPUとの互換性のために8ビット単位でのアクセスが可能である.)　
+----------------------------------------+---------------------------------------------------------+
| AX (アキュムレータ)                    |  計算結果を保存するレジスタ                             |
+----------------------------------------+---------------------------------------------------------+
| BX (ベースレジスタ)                    |  DSセグメントのデータに対するポインタ                   |   
+----------------------------------------+---------------------------------------------------------+
| CX (カウントレジスタ)                  |  文字列のポインタやループのカウンタ                     |
+----------------------------------------+---------------------------------------------------------+
| DX (データレジスタ)                    |  I/O(Input/Output)ポインタ                              |
+----------------------------------------+---------------------------------------------------------+
| SI (ソースインデックス)                |  DSレジスタが指すセグメント内のデータに対するポインタ   |                
|                                        |  文字列操作では，読み取り元のアドレスを指す．  　 　    |
+----------------------------------------+---------------------------------------------------------+
| DI (デスティネーションインデックス)    |  ESレジスタが指すセグメント内のデータ．            　   |
|                                        |  文字列操作では，保存先のアドレスを指す．               |
+----------------------------------------+---------------------------------------------------------+

+================+
| フラグレジスタ | (プログラムステータス制御レジスタが公式名称．条件分岐等に使用される．)
+----------------------------------------+--------------------------------------------------------+
| OF (オーバーフローフラグ)              | 符号付演算で桁あふれが発生した場合にセット(1に)される. |
+----------------------------------------+--------------------------------------------------------+
| DF (ディレクションフラグ)              | 文字列操作命令においてポインタの増減方向を示す．       |
+----------------------------------------+--------------------------------------------------------+
| IF (インタラプト・イネーブルフラグ)    | このフラグをクリア(0)にすると外部割込みを              |
|                                        | 受け付けなくなる．                                     |
+----------------------------------------+--------------------------------------------------------+
| TF (トラップフラグ)                    | デバッガなどでシングルステップ実行するときに           |
|                                        | セット(1に)するフラグ．                                |     |
+----------------------------------------+--------------------------------------------------------+
| SF (サインフラグ)                      | 演算結果の符号を表すフラグ．演算結果が負の場合にセット |
|                                        | (1に)され，正の場合にクリア(0に)される．　　　　　　　 |
+----------------------------------------+--------------------------------------------------------+
| ZF (ゼロフラグ)                        | 演算結果がゼロの場合にセット(1に)される．              |
+----------------------------------------+--------------------------------------------------------+
| AF (補助キャリーフラグ)                | 補助キャリーフラグ．BCD演算(※1)で使用される.          |
+----------------------------------------+--------------------------------------------------------+
|                                        | 演算結果の各ビットについて，1となるビットが偶数の時は  |
| PF (パリティフラグ)                    | セット(1に)され，奇数のときはクリア(0に)される．       |
|                                        | つまり，演算結果の各ビットの1の数とPFを足すと必ず      |
|                                        | 奇数になる．パリティチェックの常とう手段．             |
+----------------------------------------+--------------------------------------------------------+
| CF (キャリーフラグ)                    | 演算の結果，桁上がりが生じた場合にセット(1に)される．  |
+----------------------------------------+--------------------------------------------------------+
※1 BCD演算については以下のページを参照
    URL : https://www.wizforest.com/diary/140720.html

+===================+
| 特殊汎用レジスタ  | (BPとSPはスタックを操作する上で使用するレジスタ．IPはちょっとタイプが異なる．)
+----------------------------------------+--------------------------------------------------------+
| BP (ベースポインタ)                    |  スタック上のデータに対するポインタ.                   | 　　　 |
+----------------------------------------+--------------------------------------------------------+
| SP (スタックポインタ)                  |  スタックのポインタとして機能する．                    |
+----------------------------------------+--------------------------------------------------------+
|                                        |  メモリのコードセグメント内のオフセットを示すポインタ．|
| IP (インストラクションポインタ)        |  CSとセットで使用され，いわゆるプログラムカウンタの    |
| (※2)                                  |  の役割をする．また，このレジスタはadd命令などで       |
|                                        |  書き換えられない.                                     |
+----------------------------------------+--------------------------------------------------------+
※2 IPに関する参考ページ
    URL : https://stackoverflow.com/questions/17777146/what-is-the-purpose-of-cs-and-ip-registers-in-intel-8086-assembly

+====================+
| セグメントレジスタ | (セグメントアドレスを指定するために使用される．これらのレジスタは自動的に使用される．)
+----------------------------------------+--------------------------------------------------------+
| CS (コードセグメント)                  | 実行プログラムがあるメモリ空間を指すセグメント．       |
+----------------------------------------+--------------------------------------------------------+
| SS (スタックセグメント)                | メモリ空間内のスタックを指すセグメント．               |
+----------------------------------------+--------------------------------------------------------+
| DS (データセグメント)                  | データを格納するメモリ空間を指すセグメント．           |
+----------------------------------------+--------------------------------------------------------+
| ES (エキストラセグメント)              | 用度はDS(データセグメント)とほぼ同じ．                 |
+----------------------------------------+--------------------------------------------------------+

セグメントの管理はOSの仕事である．ユーザはオフセットアドレスのみを使用し，OSはそれを変換する必要がある．
"0から作るOS開発"のWebページ中では，セグメントレジスタとして，上記の4つに加えてFSとGSがあると書いてある．
これは，x86(32bit CPUの)アーキテクチャにおいて存在するものであり，16bit CPUには存在しない．

ここからはセグメントの概念について説明する．
上記のCPU(8086)の説明の部分でも述べたが，セグメントは8086より登場した概念である．
セグメントは16ビットCPU(8086)において，8ビットCPU時代と同様のメモリ操作が行えるように，
互換性を意識して実装された仕組みであるといえる．
8ビットCPU(8080)の時代，アクセス可能なメモリ領域が64KBであったことから，
16ビットCPU(8086)でのセグメントのサイズも64KBに設定された．
ユーザ(プログラマ)はセグメントレジスタを用いて，メモリ上の任意のアドレス領域にセグメント領域(64KB分)を設定し，
そこからオフセットを利用してメモリ内のデータにアクセスする．
セグメントを用いるのは，上のセグメントレジスタの表から分かるように，実行プログラムのテキスト部へのアクセス，
スタックの操作，およびデータへのアクセスを行う場合である．

セグメントの開始位置を決めるのがセグメントレジスタであるが，
これらの位置を変更する命令には MOV 命令が使用できる．

-- 例 -------------------------------------
 MOV    DS, 0x07C0
-------------------------------------------

上記のようなアセンブラコードを書くことで，セグメントの開始位置を変えることができる．
このコードでは，データセグメントの開始位置が 0x7C00 となる．

セグメントを使用する際に注意する点として，セグメントの使用規則がある．これは以下のような規則である．

--------------------------------------------------------------------------------------
(セグメントの開始位置) = (セグメントレジスタに格納した値) * 16(16進数では0x10)
--------------------------------------------------------------------------------------

これはセグメントのサイズが 64KB かつCPUが使用できるメモリ領域が1MBという仕様を実現するための規則である．
[64 KB(1024 * 64) * 16 = 1 MB(1048576B)]
このようにすることで，1MBのメモリ領域の任意の場所にセグメント領域を設定することを可能としている．

上記のアセンブラコードの例では，0x07C0 を格納したため，セグメントの開始位置はこれを16倍した値である 0x7C00 となる．

ちなみに，32bit CPU(80386)ではセグメントのサイズが4GBに拡大されたため，
事実上複数のセグメントを切り替える必要のないフラットメモリモデルと呼ばれる形態となっている．

セグメントやレジスタに関する参考ページ
　URL : https://teratail.com/questions/114386 (セグメントに関して)
　　　: https://qiita.com/timwata/items/e7b7a18cc80b31fd940a (全般的に)
　　　: http://wisdom.sakura.ne.jp/programming/asm/assembly6.html (セグメントに関して)
　　　: http://www.tamasoft.co.jp/lasm/help/lasm1to2.htm (全般的に)

===========================================================================================================================

さて，長々とレジスタやセグメントに関して説明をした．
これらの説明をしたのは，OSを設計する上でこれらの概念を理解する必要があるからである．
CPUやBIOSの規則により，メモリの特定の場所にプログラムが配置される場合があるため，
アセンブラを用いてメモリ操作を行う上で，レジスタやセグメントを理解していなければ，不正なメモリ操作を行う恐れがある．
このことを避けるうえでも，レジスタやセグメントに対する理解が必要といえる．

長くなってきたため，次のファイルに続きをかく．
次のファイル名は，"part1_20190612_3.txt" である．